#version 460
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference2 : require
#extension GL_EXT_shader_atomic_float : require

#include "surfel.h"
#include "../../perFrame.glsl"
#include "surfel_common.glsl"

layout(local_size_x = SURFEL_INDIRECT_NUMTHREADS, local_size_y = 1, local_size_z = 1) in;


// Buffers (set = 0)
layout(set = 0, binding = 1) buffer _SurfelStats {
    SurfelStats surfelStats;
};

layout(set = 0, binding = 2) buffer _SurfelBuffer {
    Surfel surfels[];
} surfelBuffer;

layout(set = 0, binding = 3) buffer _SurfelGridBuffer {
    SurfelGridCell cells[];
} surfelGrid;

layout(set = 0, binding = 4) buffer _SurfelAliveBuffer_CURRENT {
    uint indices[];
} surfelAlive_current;

layout(set = 0, binding = 5) buffer _SurfelAliveBuffer_NEXT {
    uint indices[];
} surfelAlive_next;

layout(set = 0, binding = 6) buffer _SurfelDeadBuffer {
    uint indices[];
} surfelDead;

layout(set = 0, binding = 7) buffer _SurfelRayBuffer {
    SurfelRayData rays[];
} surfelRayBuffer;

// ... rest of the shader code ...

void main() {
    uint thread_id = gl_GlobalInvocationID.x;
    uint surfel_count = surfelStats.surfelCount;
    
    if (thread_id >= surfel_count) {
        return;
    }

    // 获取当前surfel索引
    uint surfel_index = surfelAlive_current.indices[thread_id];
    Surfel surfel = surfelBuffer.surfels[surfel_index];

    // 更新surfel位置和法线
    // TODO: 根据您的需求添加位置和法线的更新逻辑

    // 计算surfel所在的grid cell
    ivec3 center_cell = surfel_cell(surfel.position);
    
    // 更新grid cells中的surfel计数
    for (uint i = 0; i < 27; ++i) {
        ivec3 grid_pos = center_cell + surfel_neighbor_offsets[i];
        
        if (surfel_cellintersects(surfel, grid_pos)) {
            uint cell_index = surfel_cellindex(grid_pos);
            atomicAdd(surfelGrid.cells[cell_index].count, 1);
        }
    }

    // 检查是否需要回收surfel
    bool shortage = atomicOr(surfelStats.surfelShortage, 0) > 0;
    if (surfel.recycle_time > SURFEL_RECYCLE_TIME && shortage) {
        // 添加到死亡列表
        int dead_count = atomicAdd(surfelStats.surfelDeadcount, 1);
        surfelDead.indices[dead_count] = surfel_index;
        return;
    }

    // 保持surfel存活
    uint alive_count = atomicAdd(surfelStats.surfelNextcount, 1);
    surfelAlive_next.indices[alive_count] = surfel_index;

    // 确定surfel的ray数量
    int ray_count_request = int(clamp(surfel.max_inconsistency,0,1) * SURFEL_RAY_BOOST_MAX);
    
    // 根据recycle时间调整ray数量
    if (surfel.recycle_time > 10) {
        ray_count_request = 1;
    }
    if (surfel.recycle_time > 60) {
        ray_count_request = 0;
    }

    // 分配ray
    int ray_offset = 0;
    if (ray_count_request > 0) {
        ray_offset = atomicAdd(surfelStats.surfelRaycount, ray_count_request);
    }

    uint ray_count = (ray_offset < SURFEL_RAY_BUDGET) ? ray_count_request : 0;
    ray_count = min(ray_count, SURFEL_RAY_BUDGET - ray_offset);
    ray_count &= 0xFF;

    // 更新ray数据
    surfel.ray_offset = ray_offset & 0xFFFFFF;
    surfel.ray_count = ray_count;
    surfel.recycle = surfel.recycel+1;

    // 存储更新后的surfel
    surfelBuffer.surfels[surfel_index] = surfel;

    // 初始化ray数据
    SurfelRayData initial_ray;
    initial_ray.surfel_index = surfel_index;
    for (uint ray_index = 0; ray_index < ray_count; ++ray_index) {
        surfelRayBuffer.rays[ray_offset + ray_index] = initial_ray;
    }
}
